"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[774],{751:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>_});var s=i(4848),a=i(8453),c=i(1226),t=i(5783);const r={sidebar_position:4,title:"ROS 2 Services and Actions"},o="ROS 2 Services and Actions",l={id:"module-1-ros2/topic-3",title:"ROS 2 Services and Actions",description:"While topics provide asynchronous publish-subscribe communication, services and actions provide synchronous request-response and goal-oriented communication patterns respectively. These are essential for implementing blocking operations and complex task management in robotic systems.",source:"@site/docs/module-1-ros2/topic-3.mdx",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/topic-3",permalink:"/docs/module-1-ros2/topic-3",draft:!1,unlisted:!1,editUrl:"https://github.com/nehaltariq357/hackthon/tree/master/docs/module-1-ros2/topic-3.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"ROS 2 Services and Actions"},sidebar:"textbookSidebar",previous:{title:"ROS 2 Nodes and Topics",permalink:"/docs/module-1-ros2/topic-2"},next:{title:"Module 2: Digital Twin \u2013 Gazebo & Unity",permalink:"/docs/module-2-digital-twin/"}},d={},_=[{value:"Services in ROS 2",id:"services-in-ros-2",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:3},{value:"Creating a Service Client",id:"creating-a-service-client",level:3},{value:"Actions in ROS 2",id:"actions-in-ros-2",level:2},{value:"Creating an Action Server",id:"creating-an-action-server",level:3},{value:"Creating an Action Client",id:"creating-an-action-client",level:3},{value:"When to Use Each Communication Pattern",id:"when-to-use-each-communication-pattern",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.A,{}),"\n",(0,s.jsx)(n.h1,{id:"ros-2-services-and-actions",children:"ROS 2 Services and Actions"}),"\n",(0,s.jsx)(n.p,{children:"While topics provide asynchronous publish-subscribe communication, services and actions provide synchronous request-response and goal-oriented communication patterns respectively. These are essential for implementing blocking operations and complex task management in robotic systems."}),"\n",(0,s.jsx)(n.h2,{id:"services-in-ros-2",children:"Services in ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"Services provide synchronous request-response communication between nodes. They are ideal for operations that need a guaranteed response, such as configuration changes or simple computations."}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="add_two_ints_server.py"',children:"from example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(\n            AddTwoInts,\n            'add_two_ints',\n            self.add_two_ints_callback\n        )\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning {request.a} + {request.b} = {response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="add_two_ints_client.py"',children:"from example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClientAsync()\n    response = minimal_client.send_request(2, 3)\n    minimal_client.get_logger().info(f'Result of add_two_ints: {response.sum}')\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"actions-in-ros-2",children:"Actions in ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"Actions are used for long-running tasks that may take significant time to complete. They provide feedback during execution and can be canceled."}),"\n",(0,s.jsx)(n.h3,{id:"creating-an-action-server",children:"Creating an Action Server"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="fibonacci_action_server.py"',children:"from rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback)\n\n    def destroy(self):\n        self._action_server.destroy()\n        super().destroy_node()\n\n    def goal_callback(self, goal_request):\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        self.get_logger().info('Goal accepted, executing...')\n        goal_handle.execute()\n\n    def cancel_callback(self, goal):\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Result: {result.sequence}')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    fibonacci_action_server = FibonacciActionServer()\n    rclpy.spin(fibonacci_action_server)\n    fibonacci_action_server.destroy()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-an-action-client",children:"Creating an Action Client"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="fibonacci_action_client.py"',children:"from rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionClient(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(\n            self,\n            Fibonacci,\n            'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = FibonacciActionClient()\n    action_client.send_goal(10)\n    rclpy.spin(action_client)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-each-communication-pattern",children:"When to Use Each Communication Pattern"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Topics"}),": For continuous data streams, sensor data, or status updates where timing is not critical"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Services"}),": For operations that need a guaranteed response, configuration changes, or simple computations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": For long-running tasks that provide feedback, can be canceled, or have complex state"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service design"}),": Keep services simple and focused on a single operation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action design"}),": Use actions for tasks that take more than a few seconds to complete"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error handling"}),": Implement proper error handling for all communication patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource management"}),": Clean up resources properly when services or actions are canceled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Clearly document the expected request/response format for services and actions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Services and actions complement the topic-based communication in ROS 2, providing synchronous request-response and goal-oriented communication patterns. Understanding when and how to use each pattern is crucial for building well-architected robotic systems."}),"\n",(0,s.jsx)(c.A,{title:"ROS 2 Communication Patterns",description:"Shows the differences between topics, services, and actions in ROS 2"})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);